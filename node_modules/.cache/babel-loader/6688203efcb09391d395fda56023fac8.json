{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VoiceToggle = void 0;\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar react_client_1 = require(\"@speechly/react-client\");\n\nvar VoiceToggle = function VoiceToggle(_a) {\n  var changeOnIntent = _a.changeOnIntent,\n      changeOnEntityType = _a.changeOnEntityType,\n      changeOnEntityValue = _a.changeOnEntityValue,\n      options = _a.options,\n      displayNames = _a.displayNames,\n      value = _a.value,\n      defaultValue = _a.defaultValue,\n      onChange = _a.onChange,\n      onFinal = _a.onFinal,\n      onBlur = _a.onBlur,\n      onFocus = _a.onFocus,\n      _b = _a.focused,\n      focused = _b === void 0 ? true : _b;\n  var inputEl = react_1.useRef(null);\n\n  var _c = react_1.useState([]),\n      matchesInUpperCase = _c[0],\n      setMatchesInUpperCase = _c[1];\n\n  var _d = react_1.useState(focused),\n      _focused = _d[0],\n      _setFocused = _d[1];\n\n  var _e = react_1.useState(defaultValue !== null && defaultValue !== void 0 ? defaultValue : options[0]),\n      _lastGoodKnownValue = _e[0],\n      _setLastGoodKnownValue = _e[1];\n\n  var _f = react_1.useState(defaultValue !== null && defaultValue !== void 0 ? defaultValue : options[0]),\n      _value = _f[0],\n      _setValue = _f[1];\n\n  var _g = react_1.useState(undefined),\n      lastSegmentId = _g[0],\n      setLastSegmentId = _g[1];\n\n  var segment = react_client_1.useSpeechContext().segment;\n\n  var _onChange = function _onChange(newValue) {\n    _setValue(newValue);\n\n    if (onChange) {\n      onChange(newValue);\n    }\n  };\n\n  var _onFocus = function _onFocus() {\n    _setFocused(true); // use callback only to change parent state\n\n\n    if (!focused && onFocus) {\n      onFocus();\n    }\n  };\n\n  var _onBlur = function _onBlur() {\n    // use callback only to change parent state\n    if (_focused) {\n      _setFocused(false);\n\n      if (onBlur) {\n        onBlur();\n      }\n    }\n  };\n\n  react_1.useEffect(function () {\n    if (focused && !_focused && inputEl != null && inputEl.current != null) {\n      inputEl.current.focus();\n    }\n  }, [focused]);\n  react_1.useEffect(function () {\n    var effectiveOptions;\n\n    if (Array.isArray(changeOnIntent)) {\n      effectiveOptions = changeOnIntent;\n    } else if (Array.isArray(changeOnEntityType)) {\n      effectiveOptions = changeOnEntityType;\n    } else if (Array.isArray(changeOnEntityValue)) {\n      effectiveOptions = changeOnEntityValue;\n    } else {\n      effectiveOptions = options;\n    }\n\n    setMatchesInUpperCase(effectiveOptions.map(function (option) {\n      return option.toUpperCase();\n    }));\n  }, [options, changeOnIntent, changeOnEntityType, changeOnEntityValue]);\n  react_1.useEffect(function () {\n    if (segment) {\n      var newValue_1 = null;\n      var lastGoodKnownValue = _lastGoodKnownValue; // Update last good known value at new segment start\n\n      var segmentId = segment.contextId + \"/\" + segment.id;\n\n      if (segmentId !== lastSegmentId) {\n        setLastSegmentId(segmentId);\n        lastGoodKnownValue = value || _value;\n\n        _setLastGoodKnownValue(lastGoodKnownValue);\n      } // Define newValue if the segment contains input targeted to this component\n\n\n      var candidates = void 0;\n\n      if (Array.isArray(changeOnIntent)) {\n        candidates = [segment.intent.intent];\n      } else {\n        // React if no intent defined; or a specified intent is defined\n        if (!changeOnIntent || segment.intent.intent === changeOnIntent) {\n          if (Array.isArray(changeOnEntityType)) {\n            candidates = segment.entities.map(function (entity) {\n              return entity.type;\n            });\n          } else {\n            candidates = segment.entities.filter(function (entity) {\n              return entity.type === changeOnEntityType;\n            }).map(function (entity) {\n              return entity.value;\n            });\n          }\n        }\n      }\n\n      if (candidates && candidates.length > 0) {\n        // Match by each candidate against the match values\n        candidates.forEach(function (candidateName) {\n          var index = matchesInUpperCase.findIndex(function (option) {\n            return option === candidateName.toUpperCase();\n          });\n\n          if (index >= 0) {\n            newValue_1 = options[index];\n          }\n        });\n      } // _onChange to newValue only only if defined: tentative input may retarget to another component at any time\n      // otherwise reset to last good known value\n\n\n      _onChange(newValue_1 !== null ? newValue_1 : lastGoodKnownValue);\n\n      if (segment === null || segment === void 0 ? void 0 : segment.isFinal) {\n        if (inputEl != null && inputEl.current != null) {\n          inputEl.current.blur();\n        }\n\n        if (onFinal) {\n          onFinal();\n        }\n      }\n    }\n  }, [segment]);\n  return react_1.default.createElement(\"div\", {\n    ref: inputEl,\n    className: \"widgetGroup toggle\"\n  }, options.map(function (optionValue, index) {\n    return react_1.default.createElement(\"button\", {\n      key: optionValue,\n      type: \"button\",\n      className: (value || _value) === optionValue ? 'active' : '',\n      onClick: function onClick() {\n        return _onChange(optionValue);\n      }\n    }, displayNames && displayNames[index] ? displayNames[index] : optionValue);\n  }));\n};\n\nexports.VoiceToggle = VoiceToggle;","map":null,"metadata":{},"sourceType":"script"}