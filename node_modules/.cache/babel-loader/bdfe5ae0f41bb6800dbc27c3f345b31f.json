{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PushToTalkButton = void 0;\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar react_client_1 = require(\"@speechly/react-client\");\n\nvar pubsub_js_1 = __importDefault(require(\"pubsub-js\"));\n\nvar types_1 = require(\"../types\");\n\nvar HintCallout_1 = require(\"./HintCallout\");\n\nrequire(\"@speechly/browser-ui/holdable-button\");\n\nvar PushToTalkButton = function PushToTalkButton(_a) {\n  var captureKey = _a.captureKey,\n      _b = _a.size,\n      size = _b === void 0 ? '6.0rem' : _b,\n      _c = _a.gradientStops,\n      gradientStops = _c === void 0 ? ['#15e8b5', '#4fa1f9'] : _c;\n\n  var _d = react_client_1.useSpeechContext(),\n      speechState = _d.speechState,\n      toggleRecording = _d.toggleRecording,\n      initialise = _d.initialise;\n\n  var _e = react_1.useState(react_client_1.SpeechState.Idle),\n      icon = _e[0],\n      setIcon = _e[1];\n\n  var buttonRef = react_1.useRef();\n  var speechStateRef = react_1.useRef(); // make stateRef always have the current count\n  // your \"fixed\" callbacks can refer to this object whenever\n  // they need the current value.  Note: the callbacks will not\n  // be reactive - they will not re-run the instant state changes,\n  // but they *will* see the current value whenever they do run\n\n  speechStateRef.current = speechState;\n  react_1.useEffect(function () {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (buttonRef === null || buttonRef === void 0 ? void 0 : buttonRef.current) {\n      var button = buttonRef.current;\n      button.onholdstart = tangentPressAction;\n      button.onholdend = tangentReleaseAction;\n    }\n  }); // Change button face according to Speechly states\n\n  react_1.useEffect(function () {\n    setIcon(speechState); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [speechState]);\n\n  var tangentPressAction = function tangentPressAction() {\n    pubsub_js_1.default.publish(types_1.SpeechlyUiEvents.TangentPress, {\n      state: speechStateRef.current\n    });\n\n    switch (speechStateRef.current) {\n      case react_client_1.SpeechState.Idle:\n      case react_client_1.SpeechState.Failed:\n        // Speechly & Mic initialise needs to be in a function triggered by event handler\n        // otherwise it won't work reliably on Safari iOS as of 11/2020\n        initialise().catch(function (err) {\n          return console.error('Error initiasing Speechly', err);\n        });\n        break;\n\n      case react_client_1.SpeechState.Ready:\n        toggleRecording().catch(function (err) {\n          return console.error('Error while starting to record', err);\n        });\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  var tangentReleaseAction = function tangentReleaseAction(e) {\n    pubsub_js_1.default.publish(types_1.SpeechlyUiEvents.TangentRelease, {\n      state: speechStateRef.current,\n      timeMs: e.timeMs\n    });\n\n    switch (speechStateRef.current) {\n      case react_client_1.SpeechState.Recording:\n        toggleRecording().catch(function (err) {\n          return console.error('Error while stopping recording', err);\n        });\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  return react_1.default.createElement(\"div\", null, react_1.default.createElement(\"holdable-button\", {\n    ref: buttonRef,\n    capturekey: captureKey,\n    icon: icon,\n    size: size,\n    gradientstop1: gradientStops[0],\n    gradientstop2: gradientStops[1]\n  }), react_1.default.createElement(HintCallout_1.HintCallout, null));\n};\n\nexports.PushToTalkButton = PushToTalkButton;","map":null,"metadata":{},"sourceType":"script"}