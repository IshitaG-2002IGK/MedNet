{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\RajaJ\\\\OneDrive\\\\Desktop\\\\react-component-landing-page\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\RajaJ\\\\OneDrive\\\\Desktop\\\\react-component-landing-page\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\RajaJ\\\\OneDrive\\\\Desktop\\\\react-component-landing-page\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nvar locale_code_1 = __importDefault(require(\"locale-code\"));\n\nvar uuid_1 = require(\"uuid\");\n\nvar token_1 = require(\"../websocket/token\");\n\nvar microphone_1 = require(\"../microphone\");\n\nvar websocket_1 = require(\"../websocket\");\n\nvar storage_1 = require(\"../storage\");\n\nvar types_1 = require(\"./types\");\n\nvar state_1 = require(\"./state\");\n\nvar segment_1 = require(\"./segment\");\n\nvar parsers_1 = require(\"./parsers\");\n\nvar deviceIdStorageKey = 'speechly-device-id';\nvar authTokenKey = 'speechly-auth-token';\nvar defaultApiUrl = 'wss://api.speechly.com/ws/v1';\nvar defaultLoginUrl = 'https://api.speechly.com/login';\nvar defaultLanguage = 'en-US';\n/**\n * A client for Speechly Spoken Language Understanding (SLU) API. The client handles initializing the microphone\n * and websocket connection to Speechly API, passing control events and audio stream to the API, reading the responses\n * and dispatching them, as well as providing a high-level API for interacting with so-called speech segments.\n * @public\n */\n\nvar Client = /*#__PURE__*/function () {\n  function Client(options) {\n    var _this = this;\n\n    _classCallCheck(this, Client);\n\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n\n    this.activeContexts = new Map();\n    this.reconnectAttemptCount = 5;\n    this.reconnectMinDelay = 1000;\n    this.contextStopDelay = 250;\n    this.state = types_1.ClientState.Disconnected;\n\n    this.stateChangeCb = function () {};\n\n    this.segmentChangeCb = function () {};\n\n    this.tentativeTranscriptCb = function () {};\n\n    this.tentativeEntitiesCb = function () {};\n\n    this.tentativeIntentCb = function () {};\n\n    this.transcriptCb = function () {};\n\n    this.entityCb = function () {};\n\n    this.intentCb = function () {};\n\n    this.handleWebsocketResponse = function (response) {\n      var _a;\n\n      if (_this.debug) {\n        console.log('[SpeechlyClient]', 'Received response', response);\n      }\n\n      var audio_context = response.audio_context,\n          segment_id = response.segment_id,\n          type = response.type;\n      var data = response.data;\n\n      var context = _this.activeContexts.get(audio_context);\n\n      if (context === undefined) {\n        console.warn('[SpeechlyClient]', 'Received response for non-existent context', audio_context);\n        return;\n      }\n\n      var segmentState = (_a = context.get(segment_id)) !== null && _a !== void 0 ? _a : new segment_1.SegmentState(audio_context, segment_id);\n\n      switch (type) {\n        case websocket_1.WebsocketResponseType.TentativeTranscript:\n          data = data;\n          var words = (0, parsers_1.parseTentativeTranscript)(data);\n\n          _this.tentativeTranscriptCb(audio_context, segment_id, words, data.transcript);\n\n          segmentState = segmentState.updateTranscript(words);\n          break;\n\n        case websocket_1.WebsocketResponseType.Transcript:\n          data = data;\n          var word = (0, parsers_1.parseTranscript)(data);\n\n          _this.transcriptCb(audio_context, segment_id, word);\n\n          segmentState = segmentState.updateTranscript([word]);\n          break;\n\n        case websocket_1.WebsocketResponseType.TentativeEntities:\n          data = data;\n          var entities = (0, parsers_1.parseTentativeEntities)(data);\n\n          _this.tentativeEntitiesCb(audio_context, segment_id, entities);\n\n          segmentState = segmentState.updateEntities(entities);\n          break;\n\n        case websocket_1.WebsocketResponseType.Entity:\n          data = data;\n          var entity = (0, parsers_1.parseEntity)(data);\n\n          _this.entityCb(audio_context, segment_id, entity);\n\n          segmentState = segmentState.updateEntities([entity]);\n          break;\n\n        case websocket_1.WebsocketResponseType.TentativeIntent:\n          data = data;\n          var tentativeIntent = (0, parsers_1.parseIntent)(data, false);\n\n          _this.tentativeIntentCb(audio_context, segment_id, tentativeIntent);\n\n          segmentState = segmentState.updateIntent(tentativeIntent);\n          break;\n\n        case websocket_1.WebsocketResponseType.Intent:\n          data = data;\n          var intent = (0, parsers_1.parseIntent)(data, true);\n\n          _this.intentCb(audio_context, segment_id, intent);\n\n          segmentState = segmentState.updateIntent(intent);\n          break;\n\n        case websocket_1.WebsocketResponseType.SegmentEnd:\n          segmentState = segmentState.finalize();\n          break;\n\n        default: // TODO: handle unexpected response types.\n\n      } // Update the segment in current context.\n\n\n      context.set(segment_id, segmentState); // Update current contexts.\n\n      _this.activeContexts.set(audio_context, context); // Log segment to console\n\n\n      if (_this.logSegments) {\n        console.info(segmentState.toString());\n      } // Fire segment change event.\n\n\n      _this.segmentChangeCb(segmentState.toSegment());\n    };\n\n    this.handleWebsocketClosure = function (err) {\n      if (_this.debug) {\n        console.error('[SpeechlyClient]', 'Server connection closed', err);\n      } // If for some reason deviceId is missing, there's nothing else we can do but fail completely.\n\n\n      if (_this.deviceId === undefined) {\n        _this.setState(types_1.ClientState.Failed);\n\n        return;\n      } // Make sure we don't have concurrent reconnection procedures or attempt to reconnect from a failed state.\n\n\n      if (_this.state === types_1.ClientState.Connecting || _this.state === types_1.ClientState.Failed) {\n        return;\n      }\n\n      _this.setState(types_1.ClientState.Connecting);\n    };\n\n    this.sampleRate = (_a = options.sampleRate) !== null && _a !== void 0 ? _a : microphone_1.DefaultSampleRate;\n\n    try {\n      var constraints = window.navigator.mediaDevices.getSupportedConstraints();\n      this.nativeResamplingSupported = constraints.sampleRate === true;\n\n      if (options.autoGainControl != null && options.autoGainControl) {\n        // @ts-ignore\n        this.autoGainControl = constraints.autoGainControl === true;\n      } else {\n        this.autoGainControl = false;\n      }\n    } catch (_o) {\n      this.nativeResamplingSupported = false;\n      this.autoGainControl = false;\n    }\n\n    var language = (_b = options.language) !== null && _b !== void 0 ? _b : defaultLanguage;\n\n    if (!(locale_code_1.default.validate(language) || locale_code_1.default.validateLanguageCode(\"\".concat(language.substring(0, 2), \"-XX\")) && /^..-\\d\\d\\d$/.test(language))) {\n      throw Error(\"[SpeechlyClient] Invalid language \\\"\".concat(language, \"\\\"\"));\n    }\n\n    this.debug = (_c = options.debug) !== null && _c !== void 0 ? _c : false;\n    this.logSegments = (_d = options.logSegments) !== null && _d !== void 0 ? _d : false;\n    this.loginUrl = (_e = options.loginUrl) !== null && _e !== void 0 ? _e : defaultLoginUrl;\n    this.appId = (_f = options.appId) !== null && _f !== void 0 ? _f : undefined;\n    this.projectId = (_g = options.projectId) !== null && _g !== void 0 ? _g : undefined;\n    var apiUrl = generateWsUrl((_h = options.apiUrl) !== null && _h !== void 0 ? _h : defaultApiUrl, language, (_j = options.sampleRate) !== null && _j !== void 0 ? _j : microphone_1.DefaultSampleRate);\n    this.apiClient = (_k = options.apiClient) !== null && _k !== void 0 ? _k : new websocket_1.WebWorkerController();\n\n    if (this.appId !== undefined && this.projectId !== undefined) {\n      throw Error('[SpeechlyClient] You cannot use both appId and projectId at the same time');\n    }\n\n    this.storage = (_l = options.storage) !== null && _l !== void 0 ? _l : new storage_1.LocalStorage();\n    this.deviceId = this.storage.getOrSet(deviceIdStorageKey, uuid_1.v4);\n    var storedToken = this.storage.get(authTokenKey); // 2. Fetch auth token. It doesn't matter if it's not present.\n\n    this.initializeApiClientPromise = new Promise(function (resolve) {\n      _this.resolveInitialization = resolve;\n    });\n\n    if (storedToken == null || !(0, token_1.validateToken)(storedToken, this.projectId, this.appId, this.deviceId)) {\n      (0, token_1.fetchToken)(this.loginUrl, this.projectId, this.appId, this.deviceId).then(function (token) {\n        _this.authToken = token; // Cache the auth token in local storage for future use.\n\n        _this.storage.set(authTokenKey, _this.authToken);\n\n        _this.connect(apiUrl);\n      }).catch(function (err) {\n        _this.setState(types_1.ClientState.Failed);\n\n        throw err;\n      });\n    } else {\n      this.authToken = storedToken;\n      this.connect(apiUrl);\n    }\n\n    if (window.AudioContext !== undefined) {\n      this.isWebkit = false;\n    } else if (window.webkitAudioContext !== undefined) {\n      this.isWebkit = true;\n    } else {\n      throw microphone_1.ErrDeviceNotSupported;\n    }\n\n    this.microphone = (_m = options.microphone) !== null && _m !== void 0 ? _m : new microphone_1.BrowserMicrophone(this.isWebkit, this.sampleRate, this.apiClient, this.debug);\n    this.apiClient.onResponse(this.handleWebsocketResponse);\n    this.apiClient.onClose(this.handleWebsocketClosure);\n    window.SpeechlyClient = this;\n  }\n  /**\n   * Esteblish websocket connection\n   */\n\n\n  _createClass(Client, [{\n    key: \"connect\",\n    value: function connect(apiUrl) {\n      var _this2 = this;\n\n      if (this.authToken != null) {\n        this.apiClient.initialize(apiUrl, this.authToken, this.sampleRate, this.debug).then(function () {\n          if (_this2.resolveInitialization != null) {\n            _this2.resolveInitialization();\n          }\n        }).catch(function (err) {\n          throw err;\n        });\n      }\n    }\n    /**\n     * Initializes the client, by initializing the microphone and establishing connection to the API.\n     *\n     * This function HAS to be invoked by a user by e.g. binding it to a button press,\n     * or some other user-performed action.\n     *\n     * If this function is invoked without a user interaction,\n     * the microphone functionality will not work due to security restrictions by the browser.\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var opts, mediaStreamConstraints;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.initializeApiClientPromise;\n\n              case 2:\n                if (!(this.state !== types_1.ClientState.Disconnected)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw Error('Cannot initialize client - client is not in Disconnected state');\n\n              case 4:\n                this.setState(types_1.ClientState.Connecting);\n                _context.prev = 5;\n\n                // 1. Initialise the storage and fetch deviceId (or generate new one and store it).\n                // await this.storage.initialize()\n                // this.deviceId = await this.storage.getOrSet(deviceIdStorageKey, uuidv4)\n                // 2. Initialise the microphone stack.\n                if (this.isWebkit) {\n                  if (window.webkitAudioContext !== undefined) {\n                    // eslint-disable-next-line new-cap\n                    this.audioContext = new window.webkitAudioContext();\n                  }\n                } else {\n                  opts = {};\n\n                  if (this.nativeResamplingSupported) {\n                    opts.sampleRate = this.sampleRate;\n                  }\n\n                  this.audioContext = new window.AudioContext(opts);\n                }\n\n                mediaStreamConstraints = {\n                  video: false\n                };\n\n                if (this.nativeResamplingSupported || this.autoGainControl) {\n                  mediaStreamConstraints.audio = {\n                    sampleRate: this.sampleRate,\n                    // @ts-ignore\n                    autoGainControl: this.autoGainControl\n                  };\n                } else {\n                  mediaStreamConstraints.audio = true;\n                }\n\n                if (!(this.audioContext != null)) {\n                  _context.next = 20;\n                  break;\n                }\n\n                if (!this.isWebkit) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 13;\n                return this.audioContext.resume();\n\n              case 13:\n                _context.next = 15;\n                return this.apiClient.setSourceSampleRate(this.audioContext.sampleRate);\n\n              case 15:\n                this.initializeMicrophonePromise = this.microphone.initialize(this.audioContext, mediaStreamConstraints);\n                _context.next = 18;\n                return this.initializeMicrophonePromise;\n\n              case 18:\n                _context.next = 21;\n                break;\n\n              case 20:\n                throw microphone_1.ErrDeviceNotSupported;\n\n              case 21:\n                _context.next = 34;\n                break;\n\n              case 23:\n                _context.prev = 23;\n                _context.t0 = _context[\"catch\"](5);\n                _context.t1 = _context.t0;\n                _context.next = _context.t1 === microphone_1.ErrDeviceNotSupported ? 28 : _context.t1 === microphone_1.ErrNoAudioConsent ? 30 : 32;\n                break;\n\n              case 28:\n                this.setState(types_1.ClientState.NoBrowserSupport);\n                return _context.abrupt(\"break\", 33);\n\n              case 30:\n                this.setState(types_1.ClientState.NoAudioConsent);\n                return _context.abrupt(\"break\", 33);\n\n              case 32:\n                this.setState(types_1.ClientState.Failed);\n\n              case 33:\n                throw _context.t0;\n\n              case 34:\n                this.setState(types_1.ClientState.Connected);\n\n              case 35:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 23]]);\n      }));\n    }\n    /**\n     * Closes the client by closing the API connection and disabling the microphone.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var errs;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                errs = [];\n                _context2.prev = 1;\n                _context2.next = 4;\n                return this.microphone.close();\n\n              case 4:\n                _context2.next = 9;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](1);\n                // @ts-ignore\n                errs.push(_context2.t0.message);\n\n              case 9:\n                _context2.prev = 9;\n                _context2.next = 12;\n                return this.apiClient.close();\n\n              case 12:\n                _context2.next = 17;\n                break;\n\n              case 14:\n                _context2.prev = 14;\n                _context2.t1 = _context2[\"catch\"](9);\n                // @ts-ignore\n                errs.push(_context2.t1.message);\n\n              case 17:\n                this.activeContexts.clear();\n                this.setState(types_1.ClientState.Disconnected);\n\n                if (!(errs.length > 0)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                throw Error(errs.join(','));\n\n              case 21:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 6], [9, 14]]);\n      }));\n    }\n    /**\n     * Stops current context and immediately starts a new SLU context\n     * by sending a start context event to the API and unmuting the microphone.\n     * @param appId - unique identifier of an app in the dashboard.\n     */\n\n  }, {\n    key: \"switchContext\",\n    value: function switchContext(appId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.state === types_1.ClientState.Recording)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                this.resolveStopContext = undefined;\n                _context3.next = 4;\n                return this.apiClient.switchContext(appId);\n\n              case 4:\n                contextId = _context3.sent;\n                this.activeContexts.set(contextId, new Map());\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Starts a new SLU context by sending a start context event to the API and unmuting the microphone.\n     * @param cb - the callback which is invoked when the context start was acknowledged by the API.\n     */\n\n  }, {\n    key: \"startContext\",\n    value: function startContext(appId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this.resolveStopContext != null)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                this.resolveStopContext();\n                _context4.next = 4;\n                return this.stoppedContextIdPromise;\n\n              case 4:\n                if (!(this.state === types_1.ClientState.Disconnected || this.state === types_1.ClientState.Connecting)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw Error('Cannot start context - client is not connected');\n\n              case 6:\n                this.setState(types_1.ClientState.Starting);\n                _context4.next = 9;\n                return this._startContext(appId);\n\n              case 9:\n                contextId = _context4.sent;\n                return _context4.abrupt(\"return\", contextId);\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"_startContext\",\n    value: function _startContext(appId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n\n                if (!(this.projectId != null)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                _context5.next = 4;\n                return this.apiClient.startContext(appId);\n\n              case 4:\n                contextId = _context5.sent;\n                _context5.next = 12;\n                break;\n\n              case 7:\n                if (!(appId != null && this.appId !== appId)) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                throw microphone_1.ErrAppIdChangeWithoutProjectLogin;\n\n              case 9:\n                _context5.next = 11;\n                return this.apiClient.startContext();\n\n              case 11:\n                contextId = _context5.sent;\n\n              case 12:\n                _context5.next = 23;\n                break;\n\n              case 14:\n                _context5.prev = 14;\n                _context5.t0 = _context5[\"catch\"](0);\n                _context5.t1 = _context5.t0;\n                _context5.next = _context5.t1 === microphone_1.ErrAppIdChangeWithoutProjectLogin ? 19 : 21;\n                break;\n\n              case 19:\n                this.setState(types_1.ClientState.Failed);\n                return _context5.abrupt(\"break\", 22);\n\n              case 21:\n                this.setState(types_1.ClientState.Connected);\n\n              case 22:\n                throw _context5.t0;\n\n              case 23:\n                this.setState(types_1.ClientState.Recording);\n                this.microphone.unmute();\n                this.activeContexts.set(contextId, new Map());\n                return _context5.abrupt(\"return\", contextId);\n\n              case 27:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 14]]);\n      }));\n    }\n    /**\n     * Stops current SLU context by sending a stop context event to the API and muting the microphone\n     * delayed by contextStopDelay = 250 ms\n     */\n\n  }, {\n    key: \"stopContext\",\n    value: function stopContext() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this3 = this;\n\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(this.state !== types_1.ClientState.Recording && this.state !== types_1.ClientState.Starting)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw Error('Cannot stop context - client is not recording');\n\n              case 2:\n                this.setState(types_1.ClientState.Stopping);\n                this.stoppedContextIdPromise = new Promise(function (resolve) {\n                  Promise.race([new Promise(function (resolve) {\n                    return setTimeout(resolve, _this3.contextStopDelay);\n                  }), new Promise(function (resolve) {\n                    _this3.resolveStopContext = resolve;\n                  })]).then(function () {\n                    _this3._stopContext().then(function (id) {\n                      resolve(id);\n                    }).catch(function (err) {\n                      throw err;\n                    });\n                  }).catch(function (err) {\n                    throw err;\n                  });\n                });\n                _context6.next = 6;\n                return this.stoppedContextIdPromise;\n\n              case 6:\n                contextId = _context6.sent;\n                this.setState(types_1.ClientState.Connected);\n                this.activeContexts.delete(contextId);\n                return _context6.abrupt(\"return\", contextId);\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"_stopContext\",\n    value: function _stopContext() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this.microphone.mute();\n                _context7.prev = 1;\n                _context7.next = 4;\n                return this.apiClient.stopContext();\n\n              case 4:\n                contextId = _context7.sent;\n                _context7.next = 11;\n                break;\n\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](1);\n                this.setState(types_1.ClientState.Failed);\n                throw _context7.t0;\n\n              case 11:\n                return _context7.abrupt(\"return\", contextId);\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[1, 7]]);\n      }));\n    }\n    /**\n     * Adds a listener for client state change events.\n     * @param cb - the callback to invoke on state change events.\n     */\n\n  }, {\n    key: \"onStateChange\",\n    value: function onStateChange(cb) {\n      this.stateChangeCb = cb;\n    }\n    /**\n     * Adds a listener for current segment change events.\n     * @param cb - the callback to invoke on segment change events.\n     */\n\n  }, {\n    key: \"onSegmentChange\",\n    value: function onSegmentChange(cb) {\n      this.segmentChangeCb = cb;\n    }\n    /**\n     * Adds a listener for tentative transcript responses from the API.\n     * @param cb - the callback to invoke on a tentative transcript response.\n     */\n\n  }, {\n    key: \"onTentativeTranscript\",\n    value: function onTentativeTranscript(cb) {\n      this.tentativeTranscriptCb = cb;\n    }\n    /**\n     * Adds a listener for transcript responses from the API.\n     * @param cb - the callback to invoke on a transcript response.\n     */\n\n  }, {\n    key: \"onTranscript\",\n    value: function onTranscript(cb) {\n      this.transcriptCb = cb;\n    }\n    /**\n     * Adds a listener for tentative entities responses from the API.\n     * @param cb - the callback to invoke on a tentative entities response.\n     */\n\n  }, {\n    key: \"onTentativeEntities\",\n    value: function onTentativeEntities(cb) {\n      this.tentativeEntitiesCb = cb;\n    }\n    /**\n     * Adds a listener for entity responses from the API.\n     * @param cb - the callback to invoke on an entity response.\n     */\n\n  }, {\n    key: \"onEntity\",\n    value: function onEntity(cb) {\n      this.entityCb = cb;\n    }\n    /**\n     * Adds a listener for tentative intent responses from the API.\n     * @param cb - the callback to invoke on a tentative intent response.\n     */\n\n  }, {\n    key: \"onTentativeIntent\",\n    value: function onTentativeIntent(cb) {\n      this.tentativeIntentCb = cb;\n    }\n    /**\n     * Adds a listener for intent responses from the API.\n     * @param cb - the callback to invoke on an intent response.\n     */\n\n  }, {\n    key: \"onIntent\",\n    value: function onIntent(cb) {\n      this.intentCb = cb;\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(newState) {\n      if (this.state === newState) {\n        return;\n      }\n\n      if (this.debug) {\n        console.log('[SpeechlyClient]', 'State transition', (0, state_1.stateToString)(this.state), (0, state_1.stateToString)(newState));\n      }\n\n      this.state = newState;\n      this.stateChangeCb(newState);\n    }\n    /**\n     * print statistics to console\n     */\n\n  }, {\n    key: \"printStats\",\n    value: function printStats() {\n      this.microphone.printStats();\n    }\n  }]);\n\n  return Client;\n}();\n\nexports.Client = Client;\n\nfunction generateWsUrl(baseUrl, languageCode, sampleRate) {\n  var params = new URLSearchParams();\n  params.append('languageCode', languageCode);\n  params.append('sampleRate', sampleRate.toString());\n  return \"\".concat(baseUrl, \"?\").concat(params.toString());\n}","map":null,"metadata":{},"sourceType":"script"}